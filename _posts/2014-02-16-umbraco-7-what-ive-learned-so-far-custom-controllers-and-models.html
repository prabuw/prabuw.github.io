---
layout: post
title: 'Umbraco 7: What I’ve learned so far – Custom Controllers and Models'
categories:
- CMS
- Umbraco
tags:
- RenderMvcController
- Umbraco 7
status: publish
type: post
published: true
meta:
  _publicize_pending: '1'
author: 
---
<p align="justify">Moving on from document types and templates, I wanted to build a model and have a view inherit it, as per the traditional MVC structure. All pages (that have a template associated with it), result in a physical file (with a .cshtml extension) being created by Umbraco. These pages are placed in the <em>Views</em> folder.</p>
<p>Theses pages by default inherit from the following code</p>
<div class="wlWriterEditableSmartContent" id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:c3ef7304-727a-4c7f-be68-57df800392b1" style="float:none;margin:0;display:inline;padding:0;">[sourcecode language="csharp" padlinenumbers="true"]<br />
@inherits Umbraco.Web.Mvc.UmbracoTemplatePage<br />
[/sourcecode]</p>
</div>
<p>This (to my understanding) is the equivalent of the following:</p>
<div class="wlWriterEditableSmartContent" id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:cd6fe8cf-3fed-4396-8022-bcf04b208893" style="float:none;margin:0;display:inline;padding:0;">[sourcecode language="csharp"]<br />
Umbraco.Web.Mvc.UmbracoViewPage<br />
[/sourcecode]</p>
</div>
<p align="justify">RenderModel is Umbraco’s representation of the page’s information&nbsp; and content stored in the database. In fact, the data the CMS user has entered for the page is stored in a field called <em>properties</em>. Umbraco takes this and renders the view following it’s convention of looking for view in the <em>Views</em> folder.</p>
<p align="justify">Access to a property’s value can be done as such (straight from the view):</p>
<div class="wlWriterEditableSmartContent" id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:b60b0e17-5e4d-4e5a-8c52-17c5793dfa3a" style="float:none;margin:0;display:inline;padding:0;">[sourcecode language="csharp"]<br />
 @Model.Content.GetPropertyValue(&quot;PropertyName&quot;)<br />
[/sourcecode]</p>
</div>
<p align="justify">Generally, I would have to check if the property exists first, before retrieving the value. This repetitive pattern of code can be replaced with an extension method.</p>
<div class="wlWriterEditableSmartContent" id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:9e625e0c-41d2-441f-b31f-2bf58bb0e17f" style="float:none;margin:0;display:inline;padding:0;">[sourcecode language="csharp"]<br />
public static T CheckPropertyExistsAndGetValue(this IPublishedContent content, string propertyName) where T : class<br />
{<br />
    if (content.HasProperty(propertyName) &amp;&amp; content.GetProperty(propertyName).HasValue)<br />
    {<br />
        return content.GetPropertyValue(propertyName);<br />
    }</p>
<p>    return default(T);<br />
}<br />
[/sourcecode]</p>
</div>
<p align="justify">Even with an extension method, I came across situations where more logic is required.&nbsp; Previous versions of Umbraco seem to recommend placing logic in the view, mixed amongst the HTML mark up. I am more in favour of building a model (placing the logic in the model or a&nbsp; controller), and placing limited logic in the view.</p>
<p align="justify">To achieve this, I had to two things, make the view inherit from a custom model and create a custom controller for Umbraco to execute.</p>
<p>Firstly create the custom model. Note that I am extending the <em>RenderModel</em>, which allows you to get access to page’s data.</p>
<div class="wlWriterEditableSmartContent" id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:c8b48885-1f47-43c8-9254-67e29ff8018b" style="float:none;margin:0;display:inline;padding:0;">[sourcecode language="csharp"]<br />
public class PersonModel : RenderModel<br />
{<br />
	public string Name { get; set; }<br />
	public string Occupation { get; set; }</p>
<p>	public PersonModel(RenderModel model)<br />
	    : base(model.Content, model.CurrentCulture)<br />
	{<br />
	    // Code to extract the data from the render<br />
	    // model and place it in the properties above.<br />
	}<br />
}<br />
[/sourcecode]</p>
<p>Then use the custom model in the view, place the code shown below:</p>
</div>
<div class="wlWriterEditableSmartContent" id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:2d0f1db7-2691-4e7d-851a-f277fc66ff50" style="float:none;margin:0;display:inline;padding:0;">[sourcecode language="csharp"]<br />
@inherits UmbracoViewPage;<br />
[/sourcecode]</p>
</div>
<p>Finally, we need to create a custom controller that will intercept the request. This is referred as <a href="http://our.umbraco.org/documentation/Reference/Mvc/custom-controllers" target="_blank">hijacking</a> by Umbraco.&nbsp; The controller file must be placed in the Controllers folder as per the MVC conventions. It must also inherit the <em>RenderMvcController </em>class as seen below.</p>
<div class="wlWriterEditableSmartContent" id="scid:C89E2BDB-ADD3-4f7a-9810-1B7EACF446C1:bcd3a1cc-2012-40fc-bafe-de1d1a8a0cb6" style="float:none;margin:0;display:inline;padding:0;">[sourcecode language="csharp"]<br />
public class HomeController : Umbraco.Web.Mvc.RenderMvcController<br />
{<br />
    public ActionResult Index(RenderModel model)<br />
    {<br />
	var customModel = new PersonModel(model);<br />
        return View(&quot;Home&quot;, customModel);<br />
    }<br />
}<br />
[/sourcecode]</p>
</div>
<p>The convention Umbraco requires that the controller be named after the document type, so in the example above, the document type is called<em> home</em>. The name of the action corresponds to the template. However, if no action matches then the <em>Index</em> action will be executed.</p>
